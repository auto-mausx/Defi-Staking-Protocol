{
  "language": "Solidity",
  "sources": {
    "contracts/Staking.sol": {
      "content": "// stake: Lock tokens into smart contract \n// unstake: Unstake tokens from smart contract\n// claimReward: Users get reward tokens\n// What's a good reward mechanism?\n// Good reward math?\n\n\n// SPDX-License-Identifier: MIT\n\n// This version of solidity automatically checks for overflow/underflow\npragma solidity ^0.8.7;\n\n// This imports the entire contract, however to be minimalistic, we can import specific functions from the contract in order to save on gas\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nerror Staking__TransferFailed();\nerror Staking__NeedsMoreThanZero();\n\ncontract Staking {\n   IERC20 public s_stakingToken;\n   IERC20 public s_rewardToken;\n\n    // someones address to how much they staked\n    mapping(address => uint256) public s_balances;\n\n\n    // a mapping of how much each address has been paid\n    mapping(address => uint256) public s_userRewardPerTokenPaid;\n\n    // a mapping of how much rewards each address has\n    mapping(address => uint256) public s_rewards;\n\n    uint256 public constant REWARD_RATE = 100;\n    uint256 public s_totalSupply;\n    uint256 public s_rewardPerTokenStored;\n    uint256 public s_lastUpdateTime;\n\n    modifier updateReward(address account) {\n        // how much reward per token?\n        // last timestamp\n        // 12 - 1pm, user earned x tokens\n        s_rewardPerTokenStored = rewardPerToken();\n        s_lastUpdateTime = block.timestamp;\n        s_rewards[account] = earned(account);\n        s_userRewardPerTokenPaid[account] = s_rewardPerTokenStored;\n        // this continues the rest of the code in the function this is being used in\n        _;\n    }\n\n    modifier moreThanZero(uint256 amount) {\n        if (amount == 0) {\n            revert Staking__NeedsMoreThanZero();\n        }\n        _;\n    }\n\n    event Staked(address indexed user, uint256 indexed amount);\n    event WithdrewStake(address indexed user, uint256 indexed amount);\n    event RewardsClaimed(address indexed user, uint256 indexed amount);\n\n\n    constructor(address stakingToken, address rewardToken) {\n        s_stakingToken = IERC20(stakingToken);\n        s_rewardToken = IERC20(rewardToken);\n    }\n\n    function earned(address account) public view returns(uint256) {\n        uint256 currentBalance = s_balances[account];\n        // how much they have been paid already\n        uint256 amountPaid = s_userRewardPerTokenPaid[account];\n        uint256 currentRewardPerToken = rewardPerToken();\n        uint256 pastRewards = s_rewards[account];\n        uint256 tokensEarned = ((currentBalance * (currentRewardPerToken - amountPaid))/1e18) + pastRewards;\n        return tokensEarned;\n    }\n\n    // based on how long it's been during this most recent snapshot\n    function rewardPerToken() public view returns(uint256) {\n        if (s_totalSupply == 0) {\n            return s_rewardPerTokenStored;\n        }\n        return s_rewardPerTokenStored + (((block.timestamp - s_lastUpdateTime) * REWARD_RATE * 1e18)/ s_totalSupply);\n    }\n    // do we allow any token? - not yet, only one erc20\n    // chainlink stuff to convert prices between tokens for keeping track of value\n    // or only specific tokens?\n\n    // External is cheaper than public\n    // The additional functions in this definition are called modifiers, \n    // and they get ran when it is noted in the modifier definition. \n    // In our case, the modifier would be ran FIRST, as notated by the \"_;\" char\n    // in the modifier definition.\n    function stake(uint256 amount) external updateReward(msg.sender) moreThanZero(amount) {\n        // keep track of how much this user has staked\n        // Keep track of how much token we have total\n        // transfer tokens to this contract\n\n        // Should I be using safemath for these?\n        //  Will need to do research and revisit\n        s_balances[msg.sender] = s_balances[msg.sender] + amount;\n        s_totalSupply = s_totalSupply + amount;\n        // emit event\n        emit Staked(msg.sender, amount);\n\n        // IERC20 Has transferFrom function\n\n        // The reason why we do this check here instead of before the logic is to prevent reentrancy attacks\n        // Learn more here: https://solidity-by-example.org/hacks/re-entrancy\n        bool success = s_stakingToken.transferFrom(msg.sender, address(this), amount);\n        // require(success, \"Failed\"); This is more gas expensive than the below function because it returns a string.\n        // Instead we are saying if this is NOT successful, return this function I declared at the top \"Staking__TransferFailed()\"\n        if(!success) {\n            // revert undos all the above logical changes and resets the transactions\n            revert Staking__TransferFailed();\n        }\n    }\n\n    function withdraw(uint256 amount) external updateReward(msg.sender) moreThanZero(amount) {\n        s_balances[msg.sender] = s_balances[msg.sender] - amount;\n        s_totalSupply = s_totalSupply - amount;\n\n        // IERC20 has a transfer function to use since we have tokens already to transfer\n        // You can also use the transferFrom function like so:\n        // bool success = s_stakingToken.transferFrom(address(this), msg.sender, amount);\n        emit WithdrewStake(msg.sender, amount);\n\n        bool success = s_stakingToken.transfer(msg.sender, amount);\n\n        if(!success) {\n            revert Staking__TransferFailed();\n        }\n    }\n\n    function claimReward() external updateReward(msg.sender) {\n        uint256 reward = s_rewards[msg.sender];\n        s_rewards[msg.sender] = 0;\n        emit RewardsClaimed(msg.sender, reward);\n        bool success = s_rewardToken.transfer(msg.sender, reward);\n        if (!success) {\n            revert Staking__TransferFailed();\n        }\n        // how much reward do they get?\n\n        // The contract will emit X tokens per second\n        // Then dispurse them to all token stakers\n\n        // 100 tokens / second\n        // staked: 50 staked tokens, 20 staked, 30 staked\n        // rewards: 50 reward tokens, 20 reward tokens, 30 reward tokens\n\n        // staked: 100, 50, 20, 30 (total = 200)\n        // rewards: 50, 25, 10, 15\n\n        // why not 1 to 1? - bankrupt the protocol\n        \n\n        // More people that are in this pool, the less APR is going to get less and less\n        // 5 seconds, 1 person had 100 tokens staked = reward 500 tokens\n        // 6 seconds, 2 persons had 100 tokens staked each:\n        //      Person 1: 550\n        //      Person 2: 50\n        // between seconds 1 and 5: person 1 got 500 tokens\n        // at second 6 on, person 1 gets 50 tokens now\n\n\n        // 100 Tokens per sec\n        // 1 token / staked token\n\n        // Time = 0\n        // Person A: 80 staked\n        // Person B: 20 staked\n\n        // Time = 1\n        // PA: 80 staked, earned: 80, Withdrawn: 0\n        // PB: 20 staked, earned: 20, Withdrawn: 0\n\n        // Time = 2\n        // PA: 80 staked, earned: 160, Withdrawn: 0\n        // PB: 20 staked, earned: 40, Withdrawn: 0\n\n        // Time = 3\n        // PA: 80 staked, earned: 240, Withdrawn: 0\n        // PB: 20 staked, earned: 60, Withdrawn: 0\n\n        // New person enters!\n\n        // Time = 3\n        // PA: 80 staked, earned: 240 + 40, Withdrawn: 0\n        // PB: 20 staked, earned: 60 + 10, Withdrawn: 0\n        // PC: 100 staked, earned: 50, Withdrawn: 0\n\n        // PA Withdraws everything\n        // Time = 4\n        // PA: 0 staked, earned: 0, Withdrawn: 280\n       \n\n    }\n// Returns staked balance\n    function getStaked(address account) public view returns (uint256) {\n        return s_balances[account];\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}